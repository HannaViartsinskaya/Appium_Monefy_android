{"uuid":"3c518208-a3b0-40c6-ba94-2ee800def111","historyId":"67f0a20299036be20a8ea2d8dbb7dc07","status":"broken","statusDetails":{"message":"waitUntil condition failed with the following reason: WebDriverError: Method is not implemented when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n  if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n    return false;\n  }\n  const isOldEdge = !!window.StyleMedia;\n  const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n  function getOverlappingElement(elem2, context) {\n    context = context || document;\n    const elemDimension = elem2.getBoundingClientRect();\n    const x = elemDimension.left + elem2.clientWidth / 2;\n    const y = elemDimension.top + elem2.clientHeight / 2;\n    return context.elementFromPoint(x, y);\n  }\n  function getOverlappingRects(elem2, context) {\n    context = context || document;\n    const rects = elem2.getClientRects();\n    const rect = rects[0];\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    return [context.elementFromPoint(x, y)];\n  }\n  function getOverlappingElements(elem2, context) {\n    return [getOverlappingElement(elem2, context)].concat(getOverlappingRects(elem2, context));\n  }\n  function nodeContains(elem2, otherNode) {\n    if (isOldEdge) {\n      let tmpElement = otherNode;\n      while (tmpElement) {\n        if (tmpElement === elem2) {\n          return true;\n        }\n        tmpElement = tmpElement.parentNode;\n        if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n          tmpElement = tmpElement.host;\n        }\n      }\n      return false;\n    }\n    return elem2.contains(otherNode);\n  }\n  function isOverlappingElementMatch(elementsFromPoint, elem2) {\n    if (elementsFromPoint.some(function(elementFromPoint) {\n      return elementFromPoint === elem2 || nodeContains(elem2, elementFromPoint);\n    })) {\n      return true;\n    }\n    let elemsWithShadowRoot = [].concat(elementsFromPoint);\n    elemsWithShadowRoot = elemsWithShadowRoot.filter(function(x) {\n      return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n    });\n    let shadowElementsFromPoint = [];\n    for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n      const shadowElement = elemsWithShadowRoot[i];\n      shadowElementsFromPoint = shadowElementsFromPoint.concat(\n        getOverlappingElements(elem2, shadowElement.shadowRoot)\n      );\n    }\n    shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n    shadowElementsFromPoint = shadowElementsFromPoint.filter(function(x) {\n      return !elementsFromPoint.includes(x);\n    });\n    if (shadowElementsFromPoint.length === 0) {\n      return false;\n    }\n    return isOverlappingElementMatch(shadowElementsFromPoint, elem2);\n  }\n  function isElementInViewport(elem2) {\n    if (!elem2.getBoundingClientRect) {\n      return false;\n    }\n    const rect = elem2.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    const vertInView = rect.top <= windowHeight && rect.top + rect.height > 0;\n    const horInView = rect.left <= windowWidth && rect.left + rect.width > 0;\n    return vertInView && horInView;\n  }\n  function isEnabled(elem2) {\n    return elem2.disabled !== true;\n  }\n  function hasOverlaps(elem2) {\n    return !isOverlappingElementMatch(getOverlappingElements(elem2), elem2);\n  }\n  function isFullyDisplayedInViewport(elem2) {\n    return isElementInViewport(elem2) && !hasOverlaps(elem2);\n  }\n  function getViewportScrollPositions() {\n    return {\n      // Cross-browser compatibility\n      x: window.scrollX !== null && window.scrollX !== void 0 ? window.scrollX : window.pageXOffset,\n      y: window.scrollY !== null && window.scrollY !== void 0 ? window.scrollY : window.pageYOffset\n    };\n  }\n  let _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n  if (!_isFullyDisplayedInViewport) {\n    const { x: originalX, y: originalY } = getViewportScrollPositions();\n    elem.scrollIntoView(scrollIntoViewFullSupport ? { block: \"center\", inline: \"center\" } : false);\n    _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n    const { x: currentX, y: currentY } = getViewportScrollPositions();\n    if (currentX !== originalX || currentY !== originalY) {\n      window.scroll(originalX, originalY);\n    }\n  }\n  return _isFullyDisplayedInViewport && isEnabled(elem);\n}\"","trace":"Error: waitUntil condition failed with the following reason: WebDriverError: Method is not implemented when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n  if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n    return false;\n  }\n  const isOldEdge = !!window.StyleMedia;\n  const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n  function getOverlappingElement(elem2, context) {\n    context = context || document;\n    const elemDimension = elem2.getBoundingClientRect();\n    const x = elemDimension.left + elem2.clientWidth / 2;\n    const y = elemDimension.top + elem2.clientHeight / 2;\n    return context.elementFromPoint(x, y);\n  }\n  function getOverlappingRects(elem2, context) {\n    context = context || document;\n    const rects = elem2.getClientRects();\n    const rect = rects[0];\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    return [context.elementFromPoint(x, y)];\n  }\n  function getOverlappingElements(elem2, context) {\n    return [getOverlappingElement(elem2, context)].concat(getOverlappingRects(elem2, context));\n  }\n  function nodeContains(elem2, otherNode) {\n    if (isOldEdge) {\n      let tmpElement = otherNode;\n      while (tmpElement) {\n        if (tmpElement === elem2) {\n          return true;\n        }\n        tmpElement = tmpElement.parentNode;\n        if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n          tmpElement = tmpElement.host;\n        }\n      }\n      return false;\n    }\n    return elem2.contains(otherNode);\n  }\n  function isOverlappingElementMatch(elementsFromPoint, elem2) {\n    if (elementsFromPoint.some(function(elementFromPoint) {\n      return elementFromPoint === elem2 || nodeContains(elem2, elementFromPoint);\n    })) {\n      return true;\n    }\n    let elemsWithShadowRoot = [].concat(elementsFromPoint);\n    elemsWithShadowRoot = elemsWithShadowRoot.filter(function(x) {\n      return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n    });\n    let shadowElementsFromPoint = [];\n    for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n      const shadowElement = elemsWithShadowRoot[i];\n      shadowElementsFromPoint = shadowElementsFromPoint.concat(\n        getOverlappingElements(elem2, shadowElement.shadowRoot)\n      );\n    }\n    shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n    shadowElementsFromPoint = shadowElementsFromPoint.filter(function(x) {\n      return !elementsFromPoint.includes(x);\n    });\n    if (shadowElementsFromPoint.length === 0) {\n      return false;\n    }\n    return isOverlappingElementMatch(shadowElementsFromPoint, elem2);\n  }\n  function isElementInViewport(elem2) {\n    if (!elem2.getBoundingClientRect) {\n      return false;\n    }\n    const rect = elem2.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    const vertInView = rect.top <= windowHeight && rect.top + rect.height > 0;\n    const horInView = rect.left <= windowWidth && rect.left + rect.width > 0;\n    return vertInView && horInView;\n  }\n  function isEnabled(elem2) {\n    return elem2.disabled !== true;\n  }\n  function hasOverlaps(elem2) {\n    return !isOverlappingElementMatch(getOverlappingElements(elem2), elem2);\n  }\n  function isFullyDisplayedInViewport(elem2) {\n    return isElementInViewport(elem2) && !hasOverlaps(elem2);\n  }\n  function getViewportScrollPositions() {\n    return {\n      // Cross-browser compatibility\n      x: window.scrollX !== null && window.scrollX !== void 0 ? window.scrollX : window.pageXOffset,\n      y: window.scrollY !== null && window.scrollY !== void 0 ? window.scrollY : window.pageYOffset\n    };\n  }\n  let _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n  if (!_isFullyDisplayedInViewport) {\n    const { x: originalX, y: originalY } = getViewportScrollPositions();\n    elem.scrollIntoView(scrollIntoViewFullSupport ? { block: \"center\", inline: \"center\" } : false);\n    _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n    const { x: currentX, y: currentY } = getViewportScrollPositions();\n    if (currentX !== originalX || currentY !== originalY) {\n      window.scroll(originalX, originalY);\n    }\n  }\n  return _isFullyDisplayedInViewport && isEnabled(elem);\n}\"\n    ---\n  if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n    return false;\n  }\n  const isOldEdge = !!window.StyleMedia;\n  const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n  function getOverlappingElement(elem2, context) {\n    context = context || document;\n    const elemDimension = elem2.getBoundingClientRect();\n    const x = elemDimension.left + elem2.clientWidth / 2;\n    const y = elemDimension.top + elem2.clientHeight / 2;\n    return context.elementFromPoint(x, y);\n  }\n  function getOverlappingRects(elem2, context) {\n    context = context || document;\n    const rects = elem2.getClientRects();\n    const rect = rects[0];\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    return [context.elementFromPoint(x, y)];\n  }\n  function getOverlappingElements(elem2, context) {\n    return [getOverlappingElement(elem2, context)].concat(getOverlappingRects(elem2, context));\n  }\n  function nodeContains(elem2, otherNode) {\n    if (isOldEdge) {\n      let tmpElement = otherNode;\n      while (tmpElement) {\n        if (tmpElement === elem2) {\n          return true;\n        }\n        tmpElement = tmpElement.parentNode;\n        if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n          tmpElement = tmpElement.host;\n        }\n      }\n      return false;\n    }\n    return elem2.contains(otherNode);\n  }\n  function isOverlappingElementMatch(elementsFromPoint, elem2) {\n    if (elementsFromPoint.some(function(elementFromPoint) {\n      return elementFromPoint === elem2 || nodeContains(elem2, elementFromPoint);\n    })) {\n      return true;\n    }\n    let elemsWithShadowRoot = [].concat(elementsFromPoint);\n    elemsWithShadowRoot = elemsWithShadowRoot.filter(function(x) {\n      return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n    });\n    let shadowElementsFromPoint = [];\n    for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n      const shadowElement = elemsWithShadowRoot[i];\n      shadowElementsFromPoint = shadowElementsFromPoint.concat(\n        getOverlappingElements(elem2, shadowElement.shadowRoot)\n      );\n    }\n    shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n    shadowElementsFromPoint = shadowElementsFromPoint.filter(function(x) {\n      return !elementsFromPoint.includes(x);\n    });\n    if (shadowElementsFromPoint.length === 0) {\n      return false;\n    }\n    return isOverlappingElementMatch(shadowElementsFromPoint, elem2);\n  }\n  function isElementInViewport(elem2) {\n    if (!elem2.getBoundingClientRect) {\n      return false;\n    }\n    const rect = elem2.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    const vertInView = rect.top <= windowHeight && rect.top + rect.height > 0;\n    const horInView = rect.left <= windowWidth && rect.left + rect.width > 0;\n    return vertInView && horInView;\n  }\n  function isEnabled(elem2) {\n    return elem2.disabled !== true;\n  }\n  function hasOverlaps(elem2) {\n    return !isOverlappingElementMatch(getOverlappingElements(elem2), elem2);\n  }\n  function isFullyDisplayedInViewport(elem2) {\n    return isElementInViewport(elem2) && !hasOverlaps(elem2);\n  }\n  function getViewportScrollPositions() {\n    return {\n      // Cross-browser compatibility\n      x: window.scrollX !== null && window.scrollX !== void 0 ? window.scrollX : window.pageXOffset,\n      y: window.scrollY !== null && window.scrollY !== void 0 ? window.scrollY : window.pageYOffset\n    };\n  }\n  let _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n  if (!_isFullyDisplayedInViewport) {\n    const { x: originalX, y: originalY } = getViewportScrollPositions();\n    elem.scrollIntoView(scrollIntoViewFullSupport ? { block: \"center\", inline: \"center\" } : false);\n    _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n    const { x: currentX, y: currentY } = getViewportScrollPositions();\n    if (currentX !== originalX || currentY !== originalY) {\n      window.scroll(originalX, originalY);\n    }\n  }\n  return _isFullyDisplayedInViewport && isEnabled(elem);\n}\"\n    at async MainDashboard.tapBalanceBottomElement (/Users/hannanasi/development/monefy-automation/test/pageobjects/MainDashboard.ts:88:9)\n    at async Context.<anonymous> (/Users/hannanasi/development/monefy-automation/test/specs/timeRangeFiltering.test.ts:24:9)"},"stage":"finished","steps":[{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Request","type":"text/plain","source":"d59aa7e9-91eb-4c10-9ef1-9e31b73a24b1-attachment.txt"},{"name":"Response","type":"text/plain","source":"eb17c2fc-d296-4aab-9a2d-9f9ddaf2ed32-attachment.txt"}],"parameters":[],"start":1751118800948,"name":"findElement","stop":1751118801741},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Response","type":"text/plain","source":"bcf28bda-edf0-477c-b067-23b34b0ab99e-attachment.txt"}],"parameters":[],"start":1751118801745,"name":"elementClick","stop":1751118802543},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Request","type":"text/plain","source":"2ebe30f3-0958-4048-b235-505c04f4840d-attachment.txt"},{"name":"Response","type":"text/plain","source":"8a086fc4-5994-4d9d-b525-72616acc2c51-attachment.txt"}],"parameters":[],"start":1751118802543,"name":"findElement","stop":1751118802560},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Response","type":"text/plain","source":"684f5d9e-6be6-44a1-8f34-8ea411d01ca8-attachment.txt"}],"parameters":[],"start":1751118802561,"name":"elementClick","stop":1751118803359},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Request","type":"text/plain","source":"8f1ab641-648c-4967-9ab3-854a7cdb0525-attachment.txt"},{"name":"Response","type":"text/plain","source":"271408e6-19e0-4bba-89cd-70e5dbcee3f8-attachment.txt"}],"parameters":[],"start":1751118803359,"name":"findElement","stop":1751118803375},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Response","type":"text/plain","source":"5ffe07f6-43aa-43b1-a24c-21b2e29b4002-attachment.txt"}],"parameters":[],"start":1751118803376,"name":"elementClick","stop":1751118804078},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Request","type":"text/plain","source":"30622b47-83e5-4a87-a967-b81b9ae30af7-attachment.txt"},{"name":"Response","type":"text/plain","source":"a62d7f50-6317-4074-a3b0-64472e13e9bd-attachment.txt"}],"parameters":[],"start":1751118804078,"name":"findElement","stop":1751118804088},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Response","type":"text/plain","source":"eca1ae05-47e0-415a-b60a-620b2dbb1cfd-attachment.txt"}],"parameters":[],"start":1751118804089,"name":"elementClick","stop":1751118804126},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Request","type":"text/plain","source":"5415ef11-cb70-43d8-95e3-43315f3def6b-attachment.txt"},{"name":"Response","type":"text/plain","source":"9442c402-28d0-4728-be13-920c6c15af86-attachment.txt"}],"parameters":[],"start":1751118805128,"name":"findElement","stop":1751118805598},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Response","type":"text/plain","source":"1df45905-3f92-434e-8815-c300c3eba92d-attachment.txt"}],"parameters":[],"start":1751118805599,"name":"isElementDisplayed","stop":1751118805608},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Request","type":"text/plain","source":"ffc53d84-12e8-4ec7-93a4-6a94cf9451b1-attachment.txt"},{"name":"Response","type":"application/json","source":"a169ba68-bf25-463b-95ca-d6e6eed6ab5c-attachment.json"}],"parameters":[],"start":1751118805608,"name":"executeScript","stop":1751118807137},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Response","type":"text/plain","source":"eb192ee3-295a-4a96-9bf1-75208b8118c7-attachment.txt"}],"parameters":[],"start":1751118807139,"name":"isElementDisplayed","stop":1751118807149},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Request","type":"text/plain","source":"8f5f1d10-5969-498f-9bd9-7cd4d93db4a2-attachment.txt"},{"name":"Response","type":"application/json","source":"03b6a038-be22-4b91-99fc-8e1689ec41e0-attachment.json"}],"parameters":[],"start":1751118807150,"name":"executeScript","stop":1751118808678},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Response","type":"text/plain","source":"e5d501da-2576-4978-b42b-2341328b0817-attachment.txt"}],"parameters":[],"start":1751118808679,"name":"isElementDisplayed","stop":1751118808689},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Request","type":"text/plain","source":"1f11883b-ceb1-4a0e-92a7-e5413a66019a-attachment.txt"},{"name":"Response","type":"application/json","source":"fed56609-b48e-4f02-a72c-d8a63efbdefc-attachment.json"}],"parameters":[],"start":1751118808690,"name":"executeScript","stop":1751118810225},{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Response","type":"text/plain","source":"7de8ad65-0fac-475a-a672-9db6480b67d0-attachment.txt"}],"parameters":[],"start":1751118810225,"name":"isElementDisplayed","stop":1751118810235},{"status":"broken","statusDetails":{"message":"waitUntil condition failed with the following reason: WebDriverError: Method is not implemented when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n  if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n    return false;\n  }\n  const isOldEdge = !!window.StyleMedia;\n  const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n  function getOverlappingElement(elem2, context) {\n    context = context || document;\n    const elemDimension = elem2.getBoundingClientRect();\n    const x = elemDimension.left + elem2.clientWidth / 2;\n    const y = elemDimension.top + elem2.clientHeight / 2;\n    return context.elementFromPoint(x, y);\n  }\n  function getOverlappingRects(elem2, context) {\n    context = context || document;\n    const rects = elem2.getClientRects();\n    const rect = rects[0];\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    return [context.elementFromPoint(x, y)];\n  }\n  function getOverlappingElements(elem2, context) {\n    return [getOverlappingElement(elem2, context)].concat(getOverlappingRects(elem2, context));\n  }\n  function nodeContains(elem2, otherNode) {\n    if (isOldEdge) {\n      let tmpElement = otherNode;\n      while (tmpElement) {\n        if (tmpElement === elem2) {\n          return true;\n        }\n        tmpElement = tmpElement.parentNode;\n        if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n          tmpElement = tmpElement.host;\n        }\n      }\n      return false;\n    }\n    return elem2.contains(otherNode);\n  }\n  function isOverlappingElementMatch(elementsFromPoint, elem2) {\n    if (elementsFromPoint.some(function(elementFromPoint) {\n      return elementFromPoint === elem2 || nodeContains(elem2, elementFromPoint);\n    })) {\n      return true;\n    }\n    let elemsWithShadowRoot = [].concat(elementsFromPoint);\n    elemsWithShadowRoot = elemsWithShadowRoot.filter(function(x) {\n      return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n    });\n    let shadowElementsFromPoint = [];\n    for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n      const shadowElement = elemsWithShadowRoot[i];\n      shadowElementsFromPoint = shadowElementsFromPoint.concat(\n        getOverlappingElements(elem2, shadowElement.shadowRoot)\n      );\n    }\n    shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n    shadowElementsFromPoint = shadowElementsFromPoint.filter(function(x) {\n      return !elementsFromPoint.includes(x);\n    });\n    if (shadowElementsFromPoint.length === 0) {\n      return false;\n    }\n    return isOverlappingElementMatch(shadowElementsFromPoint, elem2);\n  }\n  function isElementInViewport(elem2) {\n    if (!elem2.getBoundingClientRect) {\n      return false;\n    }\n    const rect = elem2.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    const vertInView = rect.top <= windowHeight && rect.top + rect.height > 0;\n    const horInView = rect.left <= windowWidth && rect.left + rect.width > 0;\n    return vertInView && horInView;\n  }\n  function isEnabled(elem2) {\n    return elem2.disabled !== true;\n  }\n  function hasOverlaps(elem2) {\n    return !isOverlappingElementMatch(getOverlappingElements(elem2), elem2);\n  }\n  function isFullyDisplayedInViewport(elem2) {\n    return isElementInViewport(elem2) && !hasOverlaps(elem2);\n  }\n  function getViewportScrollPositions() {\n    return {\n      // Cross-browser compatibility\n      x: window.scrollX !== null && window.scrollX !== void 0 ? window.scrollX : window.pageXOffset,\n      y: window.scrollY !== null && window.scrollY !== void 0 ? window.scrollY : window.pageYOffset\n    };\n  }\n  let _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n  if (!_isFullyDisplayedInViewport) {\n    const { x: originalX, y: originalY } = getViewportScrollPositions();\n    elem.scrollIntoView(scrollIntoViewFullSupport ? { block: \"center\", inline: \"center\" } : false);\n    _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n    const { x: currentX, y: currentY } = getViewportScrollPositions();\n    if (currentX !== originalX || currentY !== originalY) {\n      window.scroll(originalX, originalY);\n    }\n  }\n  return _isFullyDisplayedInViewport && isEnabled(elem);\n}\"","trace":"Error: waitUntil condition failed with the following reason: WebDriverError: Method is not implemented when running \"execute/sync\" with method \"POST\" and args \"function isElementClickable(elem) {\n  if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n    return false;\n  }\n  const isOldEdge = !!window.StyleMedia;\n  const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n  function getOverlappingElement(elem2, context) {\n    context = context || document;\n    const elemDimension = elem2.getBoundingClientRect();\n    const x = elemDimension.left + elem2.clientWidth / 2;\n    const y = elemDimension.top + elem2.clientHeight / 2;\n    return context.elementFromPoint(x, y);\n  }\n  function getOverlappingRects(elem2, context) {\n    context = context || document;\n    const rects = elem2.getClientRects();\n    const rect = rects[0];\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    return [context.elementFromPoint(x, y)];\n  }\n  function getOverlappingElements(elem2, context) {\n    return [getOverlappingElement(elem2, context)].concat(getOverlappingRects(elem2, context));\n  }\n  function nodeContains(elem2, otherNode) {\n    if (isOldEdge) {\n      let tmpElement = otherNode;\n      while (tmpElement) {\n        if (tmpElement === elem2) {\n          return true;\n        }\n        tmpElement = tmpElement.parentNode;\n        if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n          tmpElement = tmpElement.host;\n        }\n      }\n      return false;\n    }\n    return elem2.contains(otherNode);\n  }\n  function isOverlappingElementMatch(elementsFromPoint, elem2) {\n    if (elementsFromPoint.some(function(elementFromPoint) {\n      return elementFromPoint === elem2 || nodeContains(elem2, elementFromPoint);\n    })) {\n      return true;\n    }\n    let elemsWithShadowRoot = [].concat(elementsFromPoint);\n    elemsWithShadowRoot = elemsWithShadowRoot.filter(function(x) {\n      return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n    });\n    let shadowElementsFromPoint = [];\n    for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n      const shadowElement = elemsWithShadowRoot[i];\n      shadowElementsFromPoint = shadowElementsFromPoint.concat(\n        getOverlappingElements(elem2, shadowElement.shadowRoot)\n      );\n    }\n    shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n    shadowElementsFromPoint = shadowElementsFromPoint.filter(function(x) {\n      return !elementsFromPoint.includes(x);\n    });\n    if (shadowElementsFromPoint.length === 0) {\n      return false;\n    }\n    return isOverlappingElementMatch(shadowElementsFromPoint, elem2);\n  }\n  function isElementInViewport(elem2) {\n    if (!elem2.getBoundingClientRect) {\n      return false;\n    }\n    const rect = elem2.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    const vertInView = rect.top <= windowHeight && rect.top + rect.height > 0;\n    const horInView = rect.left <= windowWidth && rect.left + rect.width > 0;\n    return vertInView && horInView;\n  }\n  function isEnabled(elem2) {\n    return elem2.disabled !== true;\n  }\n  function hasOverlaps(elem2) {\n    return !isOverlappingElementMatch(getOverlappingElements(elem2), elem2);\n  }\n  function isFullyDisplayedInViewport(elem2) {\n    return isElementInViewport(elem2) && !hasOverlaps(elem2);\n  }\n  function getViewportScrollPositions() {\n    return {\n      // Cross-browser compatibility\n      x: window.scrollX !== null && window.scrollX !== void 0 ? window.scrollX : window.pageXOffset,\n      y: window.scrollY !== null && window.scrollY !== void 0 ? window.scrollY : window.pageYOffset\n    };\n  }\n  let _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n  if (!_isFullyDisplayedInViewport) {\n    const { x: originalX, y: originalY } = getViewportScrollPositions();\n    elem.scrollIntoView(scrollIntoViewFullSupport ? { block: \"center\", inline: \"center\" } : false);\n    _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n    const { x: currentX, y: currentY } = getViewportScrollPositions();\n    if (currentX !== originalX || currentY !== originalY) {\n      window.scroll(originalX, originalY);\n    }\n  }\n  return _isFullyDisplayedInViewport && isEnabled(elem);\n}\"\n    ---\n  if (!elem.getBoundingClientRect || !elem.scrollIntoView || !elem.contains || !elem.getClientRects || !document.elementFromPoint) {\n    return false;\n  }\n  const isOldEdge = !!window.StyleMedia;\n  const scrollIntoViewFullSupport = !(window.safari || isOldEdge);\n  function getOverlappingElement(elem2, context) {\n    context = context || document;\n    const elemDimension = elem2.getBoundingClientRect();\n    const x = elemDimension.left + elem2.clientWidth / 2;\n    const y = elemDimension.top + elem2.clientHeight / 2;\n    return context.elementFromPoint(x, y);\n  }\n  function getOverlappingRects(elem2, context) {\n    context = context || document;\n    const rects = elem2.getClientRects();\n    const rect = rects[0];\n    const x = rect.left + rect.width / 2;\n    const y = rect.top + rect.height / 2;\n    return [context.elementFromPoint(x, y)];\n  }\n  function getOverlappingElements(elem2, context) {\n    return [getOverlappingElement(elem2, context)].concat(getOverlappingRects(elem2, context));\n  }\n  function nodeContains(elem2, otherNode) {\n    if (isOldEdge) {\n      let tmpElement = otherNode;\n      while (tmpElement) {\n        if (tmpElement === elem2) {\n          return true;\n        }\n        tmpElement = tmpElement.parentNode;\n        if (tmpElement && tmpElement.nodeType === 11 && tmpElement.host) {\n          tmpElement = tmpElement.host;\n        }\n      }\n      return false;\n    }\n    return elem2.contains(otherNode);\n  }\n  function isOverlappingElementMatch(elementsFromPoint, elem2) {\n    if (elementsFromPoint.some(function(elementFromPoint) {\n      return elementFromPoint === elem2 || nodeContains(elem2, elementFromPoint);\n    })) {\n      return true;\n    }\n    let elemsWithShadowRoot = [].concat(elementsFromPoint);\n    elemsWithShadowRoot = elemsWithShadowRoot.filter(function(x) {\n      return x && x.shadowRoot && x.shadowRoot.elementFromPoint;\n    });\n    let shadowElementsFromPoint = [];\n    for (let i = 0; i < elemsWithShadowRoot.length; ++i) {\n      const shadowElement = elemsWithShadowRoot[i];\n      shadowElementsFromPoint = shadowElementsFromPoint.concat(\n        getOverlappingElements(elem2, shadowElement.shadowRoot)\n      );\n    }\n    shadowElementsFromPoint = [].concat(shadowElementsFromPoint);\n    shadowElementsFromPoint = shadowElementsFromPoint.filter(function(x) {\n      return !elementsFromPoint.includes(x);\n    });\n    if (shadowElementsFromPoint.length === 0) {\n      return false;\n    }\n    return isOverlappingElementMatch(shadowElementsFromPoint, elem2);\n  }\n  function isElementInViewport(elem2) {\n    if (!elem2.getBoundingClientRect) {\n      return false;\n    }\n    const rect = elem2.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n    const vertInView = rect.top <= windowHeight && rect.top + rect.height > 0;\n    const horInView = rect.left <= windowWidth && rect.left + rect.width > 0;\n    return vertInView && horInView;\n  }\n  function isEnabled(elem2) {\n    return elem2.disabled !== true;\n  }\n  function hasOverlaps(elem2) {\n    return !isOverlappingElementMatch(getOverlappingElements(elem2), elem2);\n  }\n  function isFullyDisplayedInViewport(elem2) {\n    return isElementInViewport(elem2) && !hasOverlaps(elem2);\n  }\n  function getViewportScrollPositions() {\n    return {\n      // Cross-browser compatibility\n      x: window.scrollX !== null && window.scrollX !== void 0 ? window.scrollX : window.pageXOffset,\n      y: window.scrollY !== null && window.scrollY !== void 0 ? window.scrollY : window.pageYOffset\n    };\n  }\n  let _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n  if (!_isFullyDisplayedInViewport) {\n    const { x: originalX, y: originalY } = getViewportScrollPositions();\n    elem.scrollIntoView(scrollIntoViewFullSupport ? { block: \"center\", inline: \"center\" } : false);\n    _isFullyDisplayedInViewport = isFullyDisplayedInViewport(elem);\n    const { x: currentX, y: currentY } = getViewportScrollPositions();\n    if (currentX !== originalX || currentY !== originalY) {\n      window.scroll(originalX, originalY);\n    }\n  }\n  return _isFullyDisplayedInViewport && isEnabled(elem);\n}\"\n    at async MainDashboard.tapBalanceBottomElement (/Users/hannanasi/development/monefy-automation/test/pageobjects/MainDashboard.ts:88:9)\n    at async Context.<anonymous> (/Users/hannanasi/development/monefy-automation/test/specs/timeRangeFiltering.test.ts:24:9)"},"stage":"finished","steps":[{"status":"passed","statusDetails":{},"stage":"finished","steps":[],"attachments":[{"name":"Screenshot","type":"image/png","source":"a815590f-0749-4e63-92f3-cd7b4277c48b-attachment.png"},{"name":"Response","type":"application/json","source":"9e6c26e1-f45a-4395-80d2-1abd8b85e0d3-attachment.json"}],"parameters":[],"start":1751118810644,"name":"takeScreenshot","stop":1751118810769}],"attachments":[{"name":"Request","type":"text/plain","source":"39494522-e88b-4042-af06-624d80e4f875-attachment.txt"}],"parameters":[],"start":1751118810235,"name":"executeScript","stop":1751118810769}],"attachments":[],"parameters":[{"name":"device","value":"emulator-5554"}],"labels":[{"name":"language","value":"javascript"},{"name":"framework","value":"wdio"},{"name":"package","value":".Users.hannanasi.development.monefy-automation.test.specs.timeRangeFiltering.test.ts"},{"name":"thread","value":"0-0"},{"name":"suite","value":"Monefy allows filter users expenses & incomes by different time ranges "},{"name":"feature","value":"Monefy allows filter users expenses & incomes by different time ranges "}],"links":[],"start":1751118800946,"name":"should be able to filter","testCaseId":"67f0a20299036be20a8ea2d8dbb7dc07","stop":1751118810770}